### Waterfall
Uses the linear "Requirements, Specificiation, Design, Implementation, Verification, Maintenance" pipeline, except at each stage client feedback is taken into consideration. If development acceptance criterion, as outlined in the original requirements phase, fails; or if the client introduces new criterion during feedback, development is moved back a step.
**PROS:** Not a "closed system" like normal linear model, client can monitor progress
**CONS:** Prone to deliverables getting stuck in "development hell" where development timeline is rolled back in perpetuity

### V
Actual coding of software is done roughly halfway into development timeline. Each stage of preplanning (Requirements, Specification, High-level Design, Detailed Design) provides performance metrics and acceptance criterion that are directly applied to a stage of verification (Acceptance testing, System Testing, Integration Testing, Unit Testing, matched with the preplanning stages in reverse order).
**PROS:** You get a concrete idea on how far along development is at each stage of the process. Testing is rigorous and immediately useful as each suite of test cases have been developed for a specific iteration of the final product, from high-level non-functional reqirements to low-level functional requirements.
**CONS:** This model is allergic to any late-stage fundemental change or alteration, moreso than other models - if, during testing or coding, the client decides that the product must have additional functionality, up to four entire suites of test cases must be altered or completely re-written, not to mention the actual code as well.

### Incremental
After the initial requirements are set, develop a system through repeated, iterative work, adding new features and functionality at each step of the process. Introduce new requirements at the beginning of each iteration and work to fulfill those requirements.
**PROS:** Less resistant to the client changing their minds about what they want (the aforementioned "late-stage fundemental change") - iterative change/additions to the design document are inherently a core tenet of this model.
**CONS:** Unwary teams may find themselves drowning in technical debt if execution ever gets too far out of sync with planning. Functional prototypes delivered at the end of each iteration are highly recommended, but not required.

### Spiral
Alternate "dynamic" take on the incremental model. Each iteration of development is akin to a "growing" waterfall model, starting with just requirements at the outset and slowly growing into a full run-through of the waterfal model for iterations near the very end of development. It is "dynamic" in that teams are encouraged to diverge from the model if the need arises: development activites don't have to follow a single sequence, and not every stage of the waterfall needs to be followed at every iteration (and not necessarily in the normal order). 
**PROS:** All of the pros of the waterfall model amplified - the development timeline is able to move and shift to avoid obstacles and the client is kept informed on the progress of development.
**CONS:** High-risk high-concept model which can be fatal for incompetent, overambitious, or disorganized teams. Basically no acommodation for fundemental change in project requirements after the first couple iterations.

### Agile
Crazy new innovative "liquid" software development paradigm for yuppies and bohemians. Instead of trying to follow any concrete model, development is executed in 1-4 week long "sprints" in which a working prototype of the product is delivered and shown to the client at the end of each sprint, no matter how primitive that prototype may be. Planning is done during pre- and post-sprint meetings. Agile development is centered around the four core tenets of "The Agile Manifesto": Individuals and interactions over processes and tools, Working software prototypes over documentation, Direct client collaboration over contract negotiation, and response to change over following a plan.
**PROS:** Moreso than any other model, Agile development keeps the client happy and leaves them open to changing their mind at any stage of development. While documentation is still kept, it's not a priority, so more resources can be spent on development rather than writing extensive documentation.
**CONS:** Socially taxing and requires a team that is friendly with one another and not prone to collapsing over messy internal politics. Can fall victim to a lack of long-term vision, causing the pace of development to accordion between "exponential" and "logarithmic". Combined with the intensity of individual sprints, a team with poor direction can end up sprinting the wrong way for several months, busting their asses week after week to eventually deliver something that nobody really wanted. Also prone to just completely scamming the customer - "What did you guys do this week?" "We worked 700 billable hours to make the button on the homepage orange."

### WHICH ONE IS BEST?
I have no idea, and I can't answer this. I've not worked on a software development team yet. It would depend on the team and the client and the project.



A quick brown fox jumps over the lazy dog.
0123456789 ¿?¡!`'"., <>()[]{} &@%*^#$\/

* Wieniläinen sioux'ta puhuva ökyzombie diggaa Åsan roquefort-tacoja.
* Ça me fait peur de fêter noël là, sur cette île bizarroïde où une mère et sa môme essaient de me tuer avec un gâteau à la cigüe brûlé.
* Zwölf Boxkämpfer jagten Eva quer über den Sylter Deich.
* El pingüino Wenceslao hizo kilómetros bajo exhaustiva lluvia y frío, añoraba a su querido cachorro.